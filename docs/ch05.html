<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>第5回：■ 条件式・■ 条件分岐 · Memorandom on Julia Language v0.6.4</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Memorandom on Julia Language v0.6.4</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="LICENSE.html">MIT License</a></li><li><a class="toctext" href="LICENSEja.html">MIT License 参考和訳</a></li><li><a class="toctext" href="ch00.html">はじめに</a></li><li><a class="toctext" href="ch01.html">第1回：▶︎ 簡単なグラフを描く</a></li><li><a class="toctext" href="ch02.html">第2回：▶︎ 複数のグラフを描く</a></li><li><a class="toctext" href="ch03.html">第3回：▶︎ 連続な曲線を描く</a></li><li><a class="toctext" href="ch04.html">第4回：▶︎ 不連続な曲線を描く</a></li><li class="current"><a class="toctext" href="ch05.html">第5回：■ 条件式・■ 条件分岐</a><ul class="internal"><li><a class="toctext" href="#数の大小比較-1">■ 数の大小比較</a></li><li><a class="toctext" href="#論理型-1">■ 論理型</a></li><li><a class="toctext" href="#if文-1">■ if文</a></li><li><a class="toctext" href="#if式-1">■ if式</a></li><li><a class="toctext" href="#3項演算子-1">■ 3項演算子</a></li><li><a class="toctext" href="#論理演算-1">■ 論理演算</a></li><li><a class="toctext" href="#数の大小比較の連続した記述-1">■ 数の大小比較の連続した記述</a></li><li><a class="toctext" href="#総当たりによる不定方程式の解法-1">▶︎ 総当たりによる不定方程式の解法</a></li><li><a class="toctext" href="#格子点による平面領域の塗り分け-1">▶︎ 格子点による平面領域の塗り分け</a></li><li><a class="toctext" href="#練習-1">◀︎ 練習</a></li><li><a class="toctext" href="#練習-2">◀︎ 練習</a></li><li><a class="toctext" href="#擬似乱数-1">■ 擬似乱数</a></li><li><a class="toctext" href="#乱数による平面領域の塗り分け-1">▶︎ 乱数による平面領域の塗り分け</a></li><li><a class="toctext" href="#モンテカルロ法による平面図形の面積の推定-1">▶︎ モンテカルロ法による平面図形の面積の推定</a></li><li><a class="toctext" href="#練習-3">◀︎ 練習</a></li><li><a class="toctext" href="#関数の定義-(代入文形式)-1">■ 関数の定義 (代入文形式)</a></li><li><a class="toctext" href="#「はさみうち」法による、方程式の求解-1">▶︎ 「はさみうち」法による、方程式の求解</a></li><li><a class="toctext" href="#練習-4">◀︎ 練習</a></li><li><a class="toctext" href="#NLsolveパッケージの紹介-1">▼◀︎ NLsolveパッケージの紹介</a></li><li><a class="toctext" href="#今回のまとめ-1">★ 今回のまとめ</a></li></ul></li><li><a class="toctext" href="ch06.html">第6回：■ 整数</a></li><li><a class="toctext" href="ch07.html">第7回：■ 浮動小数点数</a></li><li><a class="toctext" href="ch08.html">第8回： ▶︎ 総和・数値積分</a></li><li><a class="toctext" href="ch09.html">第9回： ■ 配列要素の操作・▶常微分方程式の数値解法</a></li><li><a class="toctext" href="ch10.html">第10回：線形代数</a></li><li><a class="toctext" href="ch11.html">第11回：関数の定義と呼び出し</a></li><li><a class="toctext" href="ch12.html">第12回：ファイル入出力</a></li><li><a class="toctext" href="ch13.html">第13回：検討中</a></li><li><a class="toctext" href="ch14.html">第14回：検討中</a></li><li><a class="toctext" href="ch15.html">第15回：落ち葉拾い</a></li><li><a class="toctext" href="index.html">toc</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="ch05.html">第5回：■ 条件式・■ 条件分岐</a></li></ul></nav><hr/><div id="topbar"><span>第5回：■ 条件式・■ 条件分岐</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ch05-1" href="#ch05-1">第5回：■ 条件式・■ 条件分岐</a></h1><h2><a class="nav-anchor" id="数の大小比較-1" href="#数の大小比較-1">■ 数の大小比較</a></h2><p><a href="https://docs.julialang.org/en/v0.6.4/manual/mathematical-operations/#Numeric-Comparisons-1">Numeric Comparisons</a></p><h3><a class="nav-anchor" id="値が等しい・異なる-1" href="#値が等しい・異なる-1">値が等しい・異なる</a></h3><ul><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#Base.:=="><code>Base.:==</code> — Function</a></p></li><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#Base.:!="><code>Base.:!=</code> — Function</a></p></li></ul><p>演算子 <code>==</code> は、<code>a == b</code> のように用いて、値が等しいか否か判定する。 演算子 <code>!=</code> は、値が異なるか否か判定する。 成立すれば(真ならば) <code>true</code>が、 成立しなければ(偽ならば) <code>false</code> が結果となる。</p><pre><code class="language-julia-repl">julia&gt; 1 == 1
true

julia&gt; 1 == 2
false

julia&gt; 1 != 1
false

julia&gt; 1 != 2
true</code></pre><h3><a class="nav-anchor" id="より大きい-1" href="#より大きい-1">より大きい</a></h3><ul><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#Base.:%3E="><code>Base.:&gt;=</code> — Function</a></p></li><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#Base.:%3E"><code>Base.:&gt;</code> - Function</a></p></li></ul><p>演算子 <code>&gt;</code> は、<code>a &gt; b</code> のように用いて、<code>a</code>の値が<code>b</code>の値よりも大きいか否か。 演算子 <code>&gt;=</code> は、<code>a &gt;= b</code> のように用いて、<code>a</code>の値が<code>b</code>の値以上であるか否か判定する。</p><pre><code class="language-julia-repl">julia&gt; 2 &gt; 1
true

julia&gt; 2 &gt;= 1
true

julia&gt; 2 &gt;= 2
true</code></pre><h3><a class="nav-anchor" id="より小さい-1" href="#より小さい-1">より小さい</a></h3><ul><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#Base.:%3C"><code>Base.:&lt;</code> - Function</a></p></li><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#Base.:%3C="><code>Base.:&lt;=</code> - Function</a></p></li></ul><p>演算子<code>&lt;</code>は、<code>a &lt; b</code> のように用いて、<code>a</code>の値が<code>b</code>の値よりも小さいか否か。 演算子<code>&gt;=</code>は、<code>a &lt;= b</code> のように用いて、<code>a</code>の値が<code>b</code>の値以下であるか否か判定する。</p><pre><code class="language-julia-repl">julia&gt; 2 &lt; 1
false

julia&gt; 2 &lt;= 1
false

julia&gt; 2 &lt;= 2
true</code></pre><h2><a class="nav-anchor" id="論理型-1" href="#論理型-1">■ 論理型</a></h2><p>比較演算子の結果は <code>true</code> または <code>false</code> のどちらかである。 この二つの値からなるデータの種類を論理型 (logical type)という。</p><h2><a class="nav-anchor" id="if文-1" href="#if文-1">■ if文</a></h2><p><a href="https://docs.julialang.org/en/v0.6.4/manual/control-flow/#man-conditional-evaluation-1">Conditional Evaluation</a></p><p>if文は、直後に論理式をとる。 論理式の値が <code>true</code> なら、if文の次の文から、<code>end</code>, <code>else</code>, <code>elseif</code> が出現するまでの文を実行する。</p><p>条件が成り立つときだけに実行される部分を<code>if</code>ブロック(block)という。</p><p>ブロックは、字下げ (indent) で表記される。が、字下げは見やすさのためだけである。</p><pre><code class="language-julia-repl">julia&gt; x=1
1

julia&gt; y=2
2

julia&gt; if x &lt; y
         println(&quot;x は y より小さい&quot;)
       end
x は y より小さい</code></pre><p><code>if</code>ブロックの後ろに、else文が続く場合がある。 論理式の値が <code>false</code> なら、<code>else</code>文の次の文から <code>end</code> が出現するまでの文 (elseブロック)を実行する。</p><pre><code class="language-julia-repl">julia&gt; x=1
1

julia&gt; y=2
2

julia&gt; if x &lt; y
       　println(&quot;x は y より小さい&quot;)
       else
       　println(&quot;x は y より小さくない&quot;)
       end
x は y より小さい</code></pre><p><code>else</code>文の前に、<code>elseif</code>文が続く場合もある。 最初の if文の論理式が <code>false</code> なら、 elseif文の論理式を計算し、それが <code>true</code> なら、elseif 文の次の文から、<code>elseif</code>または<code>end</code> が出現するまでの文 (elseifブロック)を実行する。</p><pre><code class="language-julia-repl">julia&gt; x=1
1

julia&gt; y=2
2

julia&gt; if x &lt; y
         println(&quot;x は y より小さい&quot;)
       elseif x &gt; y
       　println(&quot;x は y より大きい&quot;)
       else
         println(&quot;x は y と等しい&quot;)
       end
x は y より小さい</code></pre><h2><a class="nav-anchor" id="if式-1" href="#if式-1">■ if式</a></h2><p>if式は、論理式が成立したブロックの最後の値を、式の値とする。</p><pre><code class="language-julia-repl">julia&gt; x=40
40

julia&gt; m=if x &gt;= 100
         &quot;x は 100 以上である&quot;
       elseif x &gt;= 50
         &quot;x は 50 以上である&quot;
       elseif x &gt;= 20
         &quot;x は 20 以上である&quot;
       else
         &quot;x は 20 よりも小さい&quot;
       end
&quot;x は 20 以上である&quot;


julia&gt; @show m
m = &quot;x は 20 以上である&quot;
&quot;x は 20 以上である&quot;</code></pre><p>if式を用いて <a href="ch04.html#絶対値関数-1">▶︎ 絶対値関数</a> を、以下のように書くこともできる。</p><pre><code class="language-julia-repl">julia&gt; myabs1(x) = if x &gt;= 0
         x
         else
         -x
         end
myabs1 (generic function with 1 method)


julia&gt; @show myabs1(-1)
myabs1(-1) = 1
1</code></pre><h2><a class="nav-anchor" id="3項演算子-1" href="#3項演算子-1">■ 3項演算子</a></h2><p><a href="https://docs.julialang.org/en/v0.6/devdocs/ast/#Macros-1">Operators</a></p><p><code>a ? b : c</code></p><p>条件<code>a</code>が真(true)なら <code>b</code>を、偽なら <code>c</code> を値とする「マクロ」である。</p><pre><code class="language-julia-repl">julia&gt; m= 2 &gt; 1 ? &quot;yes&quot; : &quot;no&quot;
&quot;yes&quot;

julia&gt; @show m
m = &quot;yes&quot;
&quot;yes&quot;</code></pre><p>if式を用いて <a href="ch04.html#絶対値関数-1">▶︎ 絶対値関数</a> を、以下のように書くこともできる。</p><pre><code class="language-julia-repl">julia&gt; myabs2(x) = x &gt;= 0 ? x : -x
myabs2 (generic function with 1 method)


julia&gt; @show myabs2(-1)
myabs2(-1) = 1
1</code></pre><h2><a class="nav-anchor" id="論理演算-1" href="#論理演算-1">■ 論理演算</a></h2><h3><a class="nav-anchor" id="論理否定-1" href="#論理否定-1">論理否定</a></h3><ul><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#Base.:!"><code>Base.:!</code> — Function</a></p></li></ul><p>論理否定 <code>! a</code>は、<code>a</code>の論理値を反転する。</p><pre><code class="language-julia-repl">julia&gt; ! true
false

julia&gt; ! false
true</code></pre><h3><a class="nav-anchor" id="論理積-1" href="#論理積-1">論理積</a></h3><ul><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#&amp;&amp;"><code>&amp;&amp;</code> - Keyword</a></p></li></ul><p>論理積 <span>$a\cdot b$</span>は、<span>$a$</span>と<span>$b$</span>との両方が<code>true</code>のときだけ <code>true</code>となる。 <span>$a$</span>と<span>$b$</span>との、少なくとも一つが <code>false</code> なら、<code>false</code>　となる。</p><pre><code class="language-julia-repl">julia&gt; true &amp;&amp; true
true

julia&gt; true &amp;&amp; false
false

julia&gt; false &amp;&amp; false
false

julia&gt; false &amp;&amp; false
false</code></pre><h3><a class="nav-anchor" id="論理和-1" href="#論理和-1">論理和</a></h3><ul><li><p><a href="https://docs.julialang.org/en/v0.6/stdlib/math/#||"><code>||</code> - Keyword</a></p></li></ul><p>論理和 論理積 <span>$a + b$</span>は、<span>$a$</span>と<span>$b$</span>との少なくとも一つが<code>true</code>のとき <code>true</code>となる。 <span>$a$</span>と<span>$b$</span>とのどちらも <code>false</code> のときは、<code>false</code>　となる。</p><pre><code class="language-julia-repl">julia&gt; true || true
true

julia&gt; true || false
true

julia&gt; false || false
false

julia&gt; false || false
false</code></pre><h2><a class="nav-anchor" id="数の大小比較の連続した記述-1" href="#数の大小比較の連続した記述-1">■ 数の大小比較の連続した記述</a></h2><p>数の比較演算子は、連続して記述できる。</p><pre><code class="language-julia-repl">julia&gt; 1 &lt; 2 &lt; 3
true

julia&gt; 1 &lt; 2 &amp;&amp; 2 &lt; 3
true</code></pre><h2><a class="nav-anchor" id="総当たりによる不定方程式の解法-1" href="#総当たりによる不定方程式の解法-1">▶︎ 総当たりによる不定方程式の解法</a></h2><p>方程式の数よりも、未知数の数が少ない方程式を不定方程式という。 未知数の性質が決まっていれば、未知数の候補を、方程式に代入して、 成り立つ未知数の組合せを求めることができる (総当たり攻撃, brute-force attack)。</p><p>問題　「負ではない三つの整数 <span>$x, y, z$</span> が、次の二つの等式を同時に満たすという。</p><div>\[x + y + z = 24\]</div><div>\[x+2y+4z = 51\]</div><p>三つの数 <span>$x, y, z$</span>の組合せを全て求めよ。」</p><p>ここで、 <span>$x, y, z$</span> は、0から24までの整数である。 <span>$x, y, z$</span> の全ての組み合わせに対して、二つの等式が成り立つ条件を、if文に渡す。</p><pre><code class="language-julia-repl">julia&gt; for z=0:24
         for y=0:24
           for x=0:24
             if x+y+z==24 &amp;&amp; x+2*y+4*z==51
               @show x,y,z
             end
           end
         end
       end
(x, y, z) = (1, 21, 2)
(x, y, z) = (3, 18, 3)
(x, y, z) = (5, 15, 4)
(x, y, z) = (7, 12, 5)
(x, y, z) = (9, 9, 6)
(x, y, z) = (11, 6, 7)
(x, y, z) = (13, 3, 8)
(x, y, z) = (15, 0, 9)</code></pre><h2><a class="nav-anchor" id="格子点による平面領域の塗り分け-1" href="#格子点による平面領域の塗り分け-1">▶︎ 格子点による平面領域の塗り分け</a></h2><p>平面座標 の第一象限 <span>$0 \le x \le 1, 0 \le y \le 1$</span> の範囲に、 格子点を配置しよう。</p><p>そのうち、<span>$x^2+y^2 \lt 1$</span> の範囲にある点を赤で、 それ以外を青で色分けして示そう。</p><p>二重の繰り返し (二重ループ)を用いた。</p><p>刻み幅は各軸 0.025 に選んだので、 格子点の総数は <span>${40}\times{40}=1600$</span> 個である。</p><p>赤色の範囲は、4分円となる。</p><div><pre><code class="language-julia">using PyPlot
for y=0:0.025:1
  for x=0:0.025:1
    c = x*x + y*y &lt; 1 ? &quot;r&quot; : &quot;b&quot;
    plot(x,y,&quot;.&quot;, color=c)
  end
end
plt[:axes]()[:set_aspect](&quot;equal&quot;)</code></pre></div><p><img src="ch05-qc1-lattice-plot.svg" alt/></p><p>今度は、二つの不等式 <span>$y &lt; x$</span> と <span>$y &lt; 1-x$</span>の両方に囲まれる領域を、 赤で示そう。</p><p>二重ループを一つの <code>for</code>文にまとめた。<code>for</code>文の右側に書かれたループ変数が内側のループに相当する。</p><div><pre><code class="language-julia">using PyPlot
for y=0:0.025:1, x=0:0.025:1
  if y &lt; x &amp;&amp; y &lt; 1-x
    c=&quot;r&quot;
  else
    c=&quot;b&quot;
  end
  plot(x,y,&quot;.&quot;, color=c)
end
plt[:axes]()[:set_aspect](&quot;equal&quot;)</code></pre></div><p><img src="ch05-qc1s-lattice-plot.svg" alt/></p><h2><a class="nav-anchor" id="練習-1" href="#練習-1">◀︎ 練習</a></h2><p>格子点の刻み幅を大きく、または、小さくして、 色分けの様子を観察してみよ。</p><p>関数<code>plot</code>のfmtパラメータを <code>.</code> から <code>o</code> (circle)に変えてみよ。 さらに、<code>markersize</code>パラメータを加えて、マーカーの大きさを調整できる。</p><p><code>plot(x,y,&quot;o&quot;, markersize=3)</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>刻み幅を小さくすると、格子点の数は急激に増える (例えば、<span>$x,y$</span>軸方向の刻みの数を2倍にすると、格子点の数は 4倍になる)ので、刻み幅を急激に小さくすべきではない。計算量が増えた場合、数分以内に計算が終わらない可能性もあるが、このような状況を経験するのも重要である。</p></div></div><h2><a class="nav-anchor" id="練習-2" href="#練習-2">◀︎ 練習</a></h2><p>以下の領域を表す条件を、式で表せ。その領域を、格子点を用いて塗り分けてみよ。</p><ul><li><p>点 (0,0)と点(1,0)を一辺とし、第一象限に描かれた正三角形</p></li><li><p>中心 <span>$\left(\dfrac{1}{2},\dfrac{1}{2}\right)$</span> , 半径 <span>$\dfrac{1}{2}$</span> の円</p></li></ul><h2><a class="nav-anchor" id="擬似乱数-1" href="#擬似乱数-1">■ 擬似乱数</a></h2><p>計算機で発生する乱数を、擬似乱数 (pseudorandom numbers)という。</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>本来の意味の「乱数」は、計算する方法がないはずである。 にもかかわらず、ある手順で乱数を発生しているので「擬似乱数」という。</p></div></div><ul><li><p><a href="https://docs.julialang.org/en/v0.6.4/stdlib/numbers/#Random-Numbers-1">Random Numbers</a></p></li><li><p><a href="https://docs.julialang.org/en/v0.6.4/stdlib/numbers/#Base.Random.rand"><code>Base.Random.rand</code> - Function</a></p></li></ul><p>関数 <code>rand()</code>は、0から1未満の擬似乱数を発生する。</p><pre><code class="language-julia-repl">julia&gt; rand()
0.6920399907542463

julia&gt; rand()
0.20730690603479052

julia&gt; rand()
0.8257828384229031</code></pre><p><a href="https://docs.julialang.org/en/v0.6.4/stdlib/numbers/#Base.Random.srand"><code>Base.Random.srand</code> - Function</a></p><p>関数 <code>srand(m)</code>は、擬似乱数の種をリセットする。 種<code>m</code>には、0から<span>$2^{32}-1$</span>までの整数を指定する。 同じ種を指定すると、同じ系列で擬似乱数を発生する。</p><pre><code class="language-julia-repl">julia&gt; srand(1234)
MersenneTwister(UInt32[0x000004d2], Base.dSFMT.DSFMT_state(Int32[-1393240018, 1073611148, 45497681, 1072875908, 436273599, 1073674613, -2043716458, 1073445557, -254908435, 1072827086  …  -599655111, 1073144102, 367655457, 1072985259, -1278750689, 1018350124, -597141475, 249849711, 382, 0]), [1.53355, 1.23991, 1.88183, 1.31799, 1.39871, 1.43625, 1.50761, 1.86799, 1.19481, 1.85672  …  1.6392, 1.78937, 1.91556, 1.74071, 1.94017, 1.61381, 1.36761, 1.24417, 1.38808, 1.57127], 382)

julia&gt; rand()
0.5908446386657102

julia&gt; rand()
0.7667970365022592

julia&gt; rand()
0.5662374165061859</code></pre><h2><a class="nav-anchor" id="乱数による平面領域の塗り分け-1" href="#乱数による平面領域の塗り分け-1">▶︎ 乱数による平面領域の塗り分け</a></h2><p>関数 <code>rand()</code> を2回用いて、座標点 <code>(x,y)</code> を発生しよう。 点の数を増やすと、これらの点は、平面の第一象限 <span>$0 \le x \lt 1, 0 \le y \lt 0$</span> の範囲を埋め尽くすはずである。</p><p>そのうち、<span>$x^2+y^2 \lt 1$</span> の範囲にある点を赤で、 それ以外を青で色分けして示そう。</p><p>点の個数は <span>$2^{10}=1024$</span> である。 格子点で図示した場合 ( <a href="ch05.html#格子点による平面領域の塗り分け-1">▶︎ 格子点による平面領域の塗り分け</a> ) に比べて 点の数は少ないが、特徴を捉えている。</p><div><pre><code class="language-julia">using PyPlot
n=2^10
for i=1:n
  x=rand()
  y=rand()
  c = x*x + y*y &lt; 1 ? &quot;r&quot; : &quot;b&quot;
  plot(x,y,&quot;.&quot;, color=c)
end
plt[:axes]()[:set_aspect](&quot;equal&quot;)</code></pre></div><p><img src="ch05-qc1-random-plot.svg" alt/></p><p>今度は、 二つの不等式 <span>$y &lt; x$</span> と <span>$y &lt; 1-x$</span> の両方に囲まれる領域だけ、赤で示そう。</p><div><pre><code class="language-julia">using PyPlot
n=2^10
for i=1:n
  x=rand()
  y=rand()
  if y &lt; x &amp;&amp; y &lt; 1-x
    c=&quot;r&quot;
  else
    c=&quot;b&quot;
  end
  plot(x,y,&quot;.&quot;, color=c)
end
plt[:axes]()[:set_aspect](&quot;equal&quot;)</code></pre></div><p><img src="ch05-qc1s-random-plot.svg" alt/></p><h2><a class="nav-anchor" id="モンテカルロ法による平面図形の面積の推定-1" href="#モンテカルロ法による平面図形の面積の推定-1">▶︎ モンテカルロ法による平面図形の面積の推定</a></h2><p>以上の例で、ランダムに落とした点の総数のうち、 図形の中に入った数を数えよう。 両者の割合から、図形の面積を推定できる。 これを、モンテカルロ (Monte Carlo)法による面積の算出法という。</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>モンテカルロ (Monte Carlo)は、モナコ公国(Monaco)の地名の一つであり、公営カジノで有名である。モンテカルロ法 (Monte Carlo Method)は、擬似乱数を用いて、数値計算やシミュレーションを行う手法の総称である。(面積を推定する手法以外の「モンテカルロ法」もある)</p></div></div><p>まず、4分円の面積を推定しよう。</p><div><pre><code class="language-julia">n=2^10
s=0
for i=1:n
  x=rand()
  y=rand()
  if x*x + y*y &lt; 1
    s += 1
  end
end</code></pre><pre><code class="language-none">s / n = 0.7685546875
pi / 4 = 0.7853981633974483
(s / n - pi / 4) / (pi / 4) = -0.021445779583424734
-0.021445779583424734</code></pre></div><p>4分円の面積は <span>$\dfrac{\pi}{4}$</span>である。 点数 1024個で、相対誤差 2% 程度の、面積推定値が得られた。</p><p>今度は、点の総数に対して、面積の推定値を描いてみる。</p><div><pre><code class="language-julia">using PyPlot
for m in 1:16
  n=2^m
  s=0
  for i=1:n
    x=rand()
    y=rand()
    if x*x + y*y &lt; 1
      s += 1
    end
  end
  plot(n, s/n, &quot;.&quot;)
  @show n, s/n
end
ylim(0.9*pi/4, 1.1*pi/4)
xlabel(&quot;n&quot;)
xscale(&quot;log&quot;)
axhline(pi/4, color=&quot;k&quot;, lw=0.5)</code></pre><pre><code class="language-none">(n, s / n) = (2, 0.5)
(n, s / n) = (4, 1.0)
(n, s / n) = (8, 1.0)
(n, s / n) = (16, 0.625)
(n, s / n) = (32, 0.84375)
(n, s / n) = (64, 0.75)
(n, s / n) = (128, 0.796875)
(n, s / n) = (256, 0.78125)
(n, s / n) = (512, 0.76953125)
(n, s / n) = (1024, 0.7900390625)
(n, s / n) = (2048, 0.77734375)
(n, s / n) = (4096, 0.7783203125)
(n, s / n) = (8192, 0.7891845703125)
(n, s / n) = (16384, 0.78314208984375)
(n, s / n) = (32768, 0.79083251953125)
(n, s / n) = (65536, 0.7855987548828125)</code></pre></div><p><img src="ch05-qc1-plot.svg" alt/></p><p>正しい面積との相対誤差を、点の総数に対して描いてみる。</p><div><pre><code class="language-julia">using PyPlot
for m in 1:16
  n=2^m
  s=0
  for i=1:n
    x=rand()
    y=rand()
    if x*x + y*y &lt; 1
      s += 1
    end
  end
  plot(n, abs(s/n-pi/4)/(pi/4), &quot;.&quot;)
end
xlabel(&quot;n&quot;)
ylabel(&quot;relative errors&quot;)
xscale(&quot;log&quot;)
yscale(&quot;log&quot;)</code></pre></div><p><img src="ch05-qc2-plot.svg" alt/></p><h2><a class="nav-anchor" id="練習-3" href="#練習-3">◀︎ 練習</a></h2><p>モンテカルロ法を用いて、以下の領域の面積を推定せよ。(これらの領域の、格子点を用いた塗り分けは、以前の例題・練習として行った)。</p><p>余裕があれば、点数に対する相対誤差の変化も描いてみよ。</p><ul><li><p>二つの不等式 <span>$y &lt; x$</span> と <span>$y &lt; 1-x$</span> の両方に囲まれる領域</p></li><li><p>点 (0,0)と点(1,0)を一辺とし、第一象限に描かれた正三角形</p></li><li><p>中心 <span>$\left(\dfrac{1}{2},\dfrac{1}{2}\right)$</span> ,　半径 <span>$\dfrac{1}{2}$</span> の円</p></li></ul><h2><a class="nav-anchor" id="関数の定義-(代入文形式)-1" href="#関数の定義-(代入文形式)-1">■ 関数の定義 (代入文形式)</a></h2><p>関数は、いくつかの値を受け取って、何らかの操作をして返す、まとまった処理である。</p><p>1行によるユーザ定義関数の例を、以下に示す。</p><pre><code class="language-julia-repl">julia&gt; f(x)=x*2-1
f (generic function with 1 method)</code></pre><p><code>(</code>の前が、ユーザ定義関数の名前である。 関数名の規則は、<a href="ch01.html#変数名の規則-1">■ 変数名の規則</a> と同じである。</p><p>括弧 <code>()</code> の中に、変数名の並びを記述する。 この変数名を、仮引数(「かり・ひきすう」 parameter)という。</p><p><code>=</code>より右が、関数の定義である。 具体的な値（実引数「じつ・ひきすう」 argument)を入れて、 関数を評価する (evaluate)。 関数の定義の中に出現した仮引数は、実引数の値に置き換えられる。</p><pre><code class="language-julia-repl">julia&gt; f(0)
-1

julia&gt; f(1)
1</code></pre><p>実引数にベクトルなどを与えて、各要素に対して評価する場合には、 関数名の直後にピリオド <code>.</code>を置く。</p><pre><code class="language-julia-repl">julia&gt; f.([1,2,3])
3-element Array{Int64,1}:
 1
 3
 5

julia&gt; f.(0:5)
6-element Array{Int64,1}:
 -1
  1
  3
  5
  7
  9</code></pre><p>仮引数は、2個以上でもよい。</p><pre><code class="language-julia-repl">julia&gt; g(x,y)=x*y
g (generic function with 1 method)

julia&gt; g(1,1)
1

julia&gt; g(&quot;a &quot;,&quot; b&quot;)
&quot;a  b&quot;</code></pre><p>数同士の <code>*</code> 演算は、数の乗算である。 文字列同士の <code>*</code>演算は、文字列の連結である。</p><p>引数の型にあわせて、正しい演算が得られていることに着目せよ。</p><h2><a class="nav-anchor" id="「はさみうち」法による、方程式の求解-1" href="#「はさみうち」法による、方程式の求解-1">▶︎ 「はさみうち」法による、方程式の求解</a></h2><p>条件判断を、繰り返し行うことで、求める答えに近づいて行く例を、 もう一つ紹介する。</p><p><a href="ch04.html#不連続な有理式を描く-1">▶︎ 不連続な有理式を描く</a> の例として挙げた分母の式 <span>$f(x)=x^3+3x^2-4x-12$</span> について、方程式 <span>$f(x)=0$</span> の解の近似値を求めてみる。</p><p>まず、<span>$y=f(x)$</span>のグラフを描こう。</p><div><pre><code class="language-julia">f(x)=x^3+3x^2-4*x-12
xs=-3.5:0.05:3

using PyPlot
plot(xs, f.(xs))
axhline(0, color=&quot;k&quot;, lw=0.5)</code></pre></div><p><img src="ch05-secant1-plot.svg" alt/></p><p>さて、 連続な関数 <span>$f(x)$</span> が、 区間 <span>$a \lt x \lt b$</span> で単調（単調増加または単調減少）であるとする。 ここで、<span>$f(a)$</span> と <span>$f(b)$</span> との符号が 異なるとき <span>$f(a)\cdot f(b)\lt 0$</span> 、 方程式 <span>$f(x)=0$</span> の解は <span>$a \lt x \lt b$</span> の区間にある。</p><p>ここで、<span>$a$</span> と <span>$b$</span> との中点 <span>$c=\dfrac{a+b}{2}$</span> をとり、<span>$f(a)$</span> と <span>$f(c)$</span> が同じ符号であれば 左端<span>$a$</span>を<span>$c$</span>に更新する。 逆に、<span>$f(b)$</span> と <span>$f(c)$</span> が同じ符号であれば 右端<span>$b$</span>を<span>$c$</span>に更新する。</p><p>この手順を繰り返すことで、 方程式 <span>$f(x)=0$</span> の解が存在する区間 <span>$a \lt x \lt b$</span> を狭めていくことができる。 この手法を「はさみうち」法という。英語では、squeeze theorem, pinching theorem, sandwich theorem などと呼ばれる。</p><p>上の関数 <span>$f(x)$</span> で <span>$a=-3.2 &lt; x &lt; b=-2.6$</span> の区間を選ぼう。</p><p>この区間で <span>$f(x)$</span> が単調であることを、まず確かめよう。</p><div><pre><code class="language-julia"># f(x)=x^3+3*x^2-4*x-12
xs=-3.2:0.01:-2.6
plot(xs, f.(xs))
axhline(0, color=&quot;k&quot;, lw=0.5)</code></pre></div><p><img src="ch05-secant1b-plot.svg" alt/></p><p>この区間で、「はさみうち」を数回繰り返してみる。</p><div><pre><code class="language-julia"># f(x)=x^3+3x^2-4*x-12
a=-3.2; b=-2.6
@show a,b
@show f(a),f(b)
for i=1:10
  c=(a+b)/2
  @show i, a, b, c, f(c)
  if f(a)*f(c) &gt; 0
    a = c
  else
    b = c
  end
end</code></pre><pre><code class="language-none">(a, b) = (-3.2, -2.6)
(f(a), f(b)) = (-1.248000000000001, 1.1039999999999974)
(i, a, b, c, f(c)) = (1, -3.2, -2.6, -2.9000000000000004, 0.4409999999999954)
(i, a, b, c, f(c)) = (2, -3.2, -2.9000000000000004, -3.0500000000000003, -0.26512500000000294)
(i, a, b, c, f(c)) = (3, -3.0500000000000003, -2.9000000000000004, -2.9750000000000005, 0.12126562499999949)
(i, a, b, c, f(c)) = (4, -3.0500000000000003, -2.9750000000000005, -3.0125, -0.06343945312499955)
(i, a, b, c, f(c)) = (5, -3.0125, -2.9750000000000005, -2.9937500000000004, 0.031015869140624375)
(i, a, b, c, f(c)) = (6, -3.0125, -2.9937500000000004, -3.0031250000000003, -0.015683624267579077)
(i, a, b, c, f(c)) = (7, -3.0031250000000003, -2.9937500000000004, -2.9984375000000005, 0.007797855377194907)
(i, a, b, c, f(c)) = (8, -3.0031250000000003, -2.9984375000000005, -3.00078125, -0.003909912586216535)
(i, a, b, c, f(c)) = (9, -3.00078125, -2.9984375000000005, -2.9996093750000004, 0.0019522095322592747)
(i, a, b, c, f(c)) = (10, -3.00078125, -2.9996093750000004, -3.0001953125000003, -0.000976791389289744)</code></pre></div><p>この範囲の解は <span>$x=-3$</span>である。</p><div><pre><code class="language-julia">@show f(-3)</code></pre><pre><code class="language-none">f(-3) = 0
0</code></pre></div><p>区間が狭まる様子を、グラフに描いてみよう。</p><div><pre><code class="language-julia"># f(x)=x^3+3x^2-4*x-12
using PyPlot
a=-3.2; b=-2.6
for i=1:15
  plot(b,i, &quot;ro&quot;)
  plot(a,i, &quot;b.&quot;)

  c=(a+b)/2
  if f(a)*f(c) &gt; 0
    a = c
  else
    b = c
  end
end
xlabel(&quot;x&quot;)
ylabel(&quot;i&quot;)</code></pre></div><p><img src="ch05-secant2-plot.svg" alt/></p><p>今度は、区間の幅 <span>$b-a$</span>をプロットしよう。 区間の幅が、単調に減少する様子が観察された。</p><div><pre><code class="language-julia"># f(x)=x^3+3x^2-4*x-12
using PyPlot
a=-3.2; b=-2.65
for i=1:30
  plot(i, b-a, &quot;r.&quot;)

  c=(a+b)/2
  if f(a)*f(c) &gt; 0
    a = c
  else
    b = c
  end
end
yscale(&quot;log&quot;)
ylabel(&quot;b-a&quot;)
xlabel(&quot;i&quot;)</code></pre></div><p><img src="ch05-secant3-plot.svg" alt/></p><h2><a class="nav-anchor" id="練習-4" href="#練習-4">◀︎ 練習</a></h2><ul><li><p>同じ関数で、異なる区間で、はさみうち法を試してみよ。</p></li><li><p>別の関数に対して、単調な区間を選び、はさみうち法を試してみよ。</p></li></ul><h2><a class="nav-anchor" id="NLsolveパッケージの紹介-1" href="#NLsolveパッケージの紹介-1">▼◀︎ NLsolveパッケージの紹介</a></h2><p><a href="https://github.com/JuliaNLSolvers/NLsolve.jl"><code>NLsolve</code></a>パッケージは、連立非線形方程式を解くためのパッケージのひとつである。</p><p><code>NLsolve</code>パッケージを用いて、上の例題を解く例を示す。ただし、まだ説明していない文法(ベクトルの添字、関数の副作用)を用いているので、学習が進んでから、再度試してみよ。</p><pre><code class="language-julia-repl">julia&gt; # Pkg.add(&quot;NLsolve&quot;) # パッケージの導入。冒頭の`#`を外して１回だけ実行すればよい。
       
       using NLsolve


julia&gt; # 解くべき関数を定義する
       function g!(r, x)
           r[1] =x[1]^3+3*x[1]^2-4*x[1]-12
       end
g! (generic function with 1 method)


julia&gt; # nlsolve関数を呼び出す
       nlsolve( g!, [-3.5], autodiff = :forward)
Results of Nonlinear Solver Algorithm
 * Algorithm: Trust-region with dogleg and autoscaling
 * Starting Point: [-3.5]
 * Zero: [-3.0]
 * Inf-norm of residuals: 0.000000
 * Iterations: 5
 * Convergence: true
   * |x - x&#39;| &lt; 0.0e+00: false
   * |f(x)| &lt; 1.0e-08: true
 * Function Calls (f): 6
 * Jacobian Calls (df/dx): 6</code></pre><h2><a class="nav-anchor" id="今回のまとめ-1" href="#今回のまとめ-1">★ 今回のまとめ</a></h2><ul><li><p>数の大小比較</p></li><li><p>if文</p></li><li><p>if式</p></li><li><p>3項演算子</p></li><li><p>論理演算</p></li><li><p>格子点による平面領域の塗り分け</p></li><li><p>擬似乱数</p></li><li><p>乱数による平面領域の塗り分け</p></li><li><p>モンテカルロ法による平面図形の面積の推定</p></li><li><p>ユーザ定義関数 (代入文の形式)</p></li><li><p>「はさみうち」法による、方程式の求解</p></li></ul><footer><hr/><a class="previous" href="ch04.html"><span class="direction">Previous</span><span class="title">第4回：▶︎ 不連続な曲線を描く</span></a><a class="next" href="ch06.html"><span class="direction">Next</span><span class="title">第6回：■ 整数</span></a></footer></article></body></html>
